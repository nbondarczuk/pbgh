/*******************************************************************************
 * LH-Specification GmbH 1996.
 *
 * All rights reserved.
 * Copying of this software or parts of this software is a violation of German
 * and International laws and will be prosecuted.
 *
 * Project  :   BGH
 *
 * File     :   parser.c
 * Created  :   Okt. 1996
 * Author(s):   B. Michler
 *
 * This is a pure C parser based on the flex and bison parser - it has the same
 * functionality and uses the same structures / interfaces.
 * The lexer is significantly faster than that generated by flex, mainly
 * because we needed a lot of string-copying with flex (this is because
 * flex works file oriented and therefore uses internal buffers, we work
 * with a buffer - so the data gets copied to the flex buffer, then to
 * the final structure. Another problem is the simulation of end-of-file
 * with flex). The token are searched as long integers (not strings) and 
 * the strings are build directly into the final structure.
 * The bison part was replaced because bison may only be used with royalty
 * free software - and other yaccs are too different between the machines / UNIX
 * derivates.
 *
 * Modified :
 * 11.10.96	B. Michler	created
 *
 *******************************************************************************/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "pbgh.h"
#include "protos.h"
#include "parser.h"
#include "gen.h"

/*
 * global
 */

extern toenBool goenVerbose;
extern toenBool goenTestOnly;
extern int goiCustomersNo;
extern int goiTryCreateEnclosure;

#define  ALC_SEGMENT	260
#define  BGM_SEGMENT	261
#define  CNT_SEGMENT	262
#define  COM_SEGMENT	263
#define  CTA_SEGMENT	264
#define  CUX_SEGMENT	265
#define  DOC_SEGMENT	266
#define  DTM_SEGMENT	267
#define  FII_SEGMENT	268
#define  FTX_SEGMENT	269
#define  IMD_SEGMENT	270
#define  LIN_SEGMENT	271
#define  LOC_SEGMENT	272
#define  MOA_SEGMENT	273
#define  NAD_SEGMENT	274
#define  PAT_SEGMENT	275
#define  PCD_SEGMENT	276
#define  PIA_SEGMENT	277
#define  PRI_SEGMENT	278
#define  QTY_SEGMENT	279
#define  RFF_SEGMENT	280
#define  TAX_SEGMENT	281
#define  UNB_SEGMENT	282
#define  UNH_SEGMENT	283
#define  UNS_SEGMENT	284
#define  UNT_SEGMENT	285
#define  UNZ_SEGMENT	286
#define  XCD_SEGMENT	287

#define  SEGMENT_ERROR	-1


static char *SCCS_VERSION = "1.0";


void fovdPrintVerInfoParser (void)
{
  printf ("%s\t\t%s\n", __FILE__, SCCS_VERSION);
}


/********************************************************************/
/*    Version of the Parser - insert new ones in the array here     */
/********************************************************************/
/* B.Michler 11.09.96: no support for Version 3.xx as bgh_prep.c    */
/* is not prepared to support new XCD !!			    */
int  aiParsVersion[] = {160, 209, 210, 304, 305, 306, 307, -1};


char *bgh_input;      /* input string */
char *bgh_input_ptr;  /* current position in the input string */

/* One (global) pointer on pointer and a simple pointer on every
 * segment and group to be processed from the timmessge
 * (The 'strange' pointer on pointer is always set to the position
 * where the next element of this type is to be attached at
 * The simple pointer is mainly used for simplify the refrencing
 */
int SegNr;
char *SegName;

char *pszCustId;		/* pointer to customer id */

static char szErr[1024];

static struct s_alc_seg **pp_alc,*p_alc; /* pointers on struct that can hold  */
                                         /* thats able to hold the info of an */
                                         /* ALC Segment. (see bgh_data.h)     */
static struct s_bgm_seg **pp_bgm,*p_bgm;
static struct s_cnt_seg **pp_cnt,*p_cnt;
static struct s_cta_seg **pp_cta,*p_cta;
static struct s_com_seg **pp_com,*p_com;
static struct s_cux_seg **pp_cux,*p_cux;
static struct s_doc_seg **pp_doc,*p_doc;
static struct s_dtm_seg **pp_dtm,*p_dtm;
static struct s_fii_seg **pp_fii,*p_fii;
static struct s_ftx_seg **pp_ftx,*p_ftx;
static struct s_imd_seg **pp_imd,*p_imd;
static struct s_lin_seg **pp_lin,*p_lin;
static struct s_loc_seg **pp_loc,*p_loc;
static struct s_nad_seg **pp_nad,*p_nad;
static struct s_moa_seg **pp_moa,*p_moa;
static struct s_pat_seg **pp_pat,*p_pat;
static struct s_pcd_seg **pp_pcd,*p_pcd;
static struct s_pia_seg **pp_pia,*p_pia;
static struct s_pri_seg **pp_pri,*p_pri;
static struct s_qty_seg **pp_qty,*p_qty;
static struct s_rff_seg **pp_rff,*p_rff;
static struct s_tax_seg **pp_tax,*p_tax;
static struct s_unh_seg **pp_unh,*p_unh;
static struct s_unb_seg **pp_unb,*p_unb;
static struct s_uns_seg **pp_uns,*p_uns;
static struct s_unt_seg **pp_unt,*p_unt;
static struct s_unz_seg **pp_unz,*p_unz;
static struct s_xcd_seg **pp_xcd,*p_xcd;
static struct s_group_1 **pp_g1,*p_g1;
static struct s_group_2 **pp_g2,*p_g2;
static struct s_group_3 **pp_g3,*p_g3;
static struct s_group_4 **pp_g4,*p_g4;
static struct s_group_5 **pp_g5,*p_g5;
static struct s_group_6 **pp_g6,*p_g6;
static struct s_group_7 **pp_g7,*p_g7;
static struct s_group_8 **pp_g8,*p_g8;
static struct s_group_22 **pp_g22,*p_g22;
static struct s_group_23 **pp_g23,*p_g23;
static struct s_group_25 **pp_g25,*p_g25;
static struct s_group_26 **pp_g26,*p_g26;
static struct s_group_30 **pp_g30,*p_g30;
static struct s_group_31 **pp_g31,*p_g31;
static struct s_group_35 **pp_g35,*p_g35;
static struct s_group_37 **pp_g37,*p_g37;
static struct s_group_38 **pp_g38,*p_g38;
static struct s_group_40 **pp_g40,*p_g40;
static struct s_group_45 **pp_g45,*p_g45;
static struct s_group_47 **pp_g47,*p_g47;
static struct s_group_99 **pp_g99,*p_g99;

static struct s_timm_message **pp_timm,*p_timm; /* There can be more than one timm  */
                                                /*message embedded in a so called  */
                                                /* interchange.                     */

static struct s_TimmInter *p_inter;  /*=&interchange;*/

/* One temporary fixpoint for every segment in the timmessage
 * In reality only used for segments that start groups
 * For example:  LIN Segement in Group22 or CTA in Group 5
 * (I have to read and to fill the Segment befor i know that i have
 * to allocate a new Group22 where the LIN Segemnt is then attached
 * at. (In the meantime its attached at hold.tmp_lin.)
 */

struct anker{
   struct s_alc_seg *tmp_alc;
   struct s_bgm_seg *tmp_bgm;
   struct s_cnt_seg *tmp_cnt;
   struct s_cta_seg *tmp_cta;
   struct s_com_seg *tmp_com;
   struct s_cux_seg *tmp_cux;
   struct s_doc_seg *tmp_doc;
   struct s_dtm_seg *tmp_dtm;
   struct s_fii_seg *tmp_fii;
   struct s_ftx_seg *tmp_ftx;
   struct s_imd_seg *tmp_imd;
   struct s_lin_seg *tmp_lin;
   struct s_loc_seg *tmp_loc;
   struct s_nad_seg *tmp_nad;
   struct s_moa_seg *tmp_moa;
   struct s_pat_seg *tmp_pat;
   struct s_pia_seg *tmp_pia;
   struct s_pcd_seg *tmp_pcd;
   struct s_pri_seg *tmp_pri;
   struct s_qty_seg *tmp_qty;
   struct s_rff_seg *tmp_rff;
   struct s_tax_seg *tmp_tax;
   struct s_unb_seg *tmp_unb;
   struct s_unh_seg *tmp_unh;
   struct s_uns_seg *tmp_uns;
   struct s_unt_seg *tmp_unt;
   struct s_unz_seg *tmp_unz;
   struct s_xcd_seg *tmp_xcd;
} hold;

char dummy[2];

#define SETRETVAL(a,b)	*ppBuf = a; *pLen = sizeof (a); *fMand = (b);

#define COLONERROR {SETRETVAL(dummy,FALSE);}
#define PLUSERROR  {SETRETVAL(dummy,FALSE);}

/* define mandatory and conditional to true and false */
#define MAND	TRUE
#define COND	FALSE

/******************************************************************************
 * fovdMallocError
 *
 * DESCRIPTION:
 * no memory for malloc
 *
 * PARAMETERS:
 *  - none -
 *
 * RETURNS:
 *  - none -
 ******************************************************************************
 */
void fovdMallocError (void)
{
  printf ("Parser out of memory: Segment %s Nr. %d", SegName, SegNr);
}


void *timm_malloc(size_t size)
{
  void *p_void;

  p_void = calloc (1, size);
  if (p_void) return (p_void);
  else
    fovdMallocError ();
  return (NULL);
}


void alc_ini (void)
{
  p_alc = (struct s_alc_seg*) calloc (sizeof (struct s_alc_seg), 1);
  if (p_alc == NULL)
    fovdMallocError ();
}

int alc_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_alc != NULL);

  switch (plus) {
  case 1:
    SETRETVAL (p_alc->v_5463, MAND);
    break;

  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void bgm_ini (void)
{
  p_bgm = (struct s_bgm_seg*) calloc (sizeof (struct s_bgm_seg), 1);
  if (p_bgm == NULL)
    fovdMallocError ();
}

int bgm_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_bgm != NULL);

  switch (plus) {
  case 1:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_bgm->v_1001, COND);
      break;
    case 4:
      SETRETVAL (p_bgm->v_1000, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  case 2:
    SETRETVAL (p_bgm->v_1004, COND);
    break;
  case 3:
    SETRETVAL (p_bgm->v_1225, COND);
    break;
  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void cnt_ini (void)
{
  p_cnt = (struct s_cnt_seg *) calloc (sizeof (struct s_cnt_seg), 1);
  if (p_cnt == NULL)
    fovdMallocError ();
}

int cnt_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_cnt != NULL);

  switch (plus) {
  case 1:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_cnt->v_6069, MAND);
      break;
    case 2:
      SETRETVAL (p_cnt->v_6066, MAND);
      break;
    case 3:
      SETRETVAL (p_cnt->v_6411, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void com_ini (void)
{
  p_com = (struct s_com_seg *) calloc (sizeof (struct s_com_seg), 1);
  if (p_com == NULL)
    fovdMallocError ();
}

int com_func (int plus,int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_com != NULL);

  switch (plus) {
  case 1:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_com->v_3148, MAND);
      break;
    case 2:
      SETRETVAL (p_com->v_3155, MAND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void cta_ini (void)
{
  p_cta = (struct s_cta_seg *) calloc (sizeof (struct s_cta_seg), 1);
  if (p_cta == NULL)
    fovdMallocError ();
}

int cta_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_cta != NULL);

  switch (plus) {
  case 1:
    SETRETVAL (p_cta->v_3139, COND);
    break;
  case 2:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_cta->v_3413, COND);
      break;
    case 2:
      SETRETVAL (p_cta->v_3412, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void cux_ini (void)
{
  p_cux = (struct s_cux_seg *) calloc (sizeof (struct s_cux_seg), 1);
  if (p_cux == NULL)
    fovdMallocError ();
}

int cux_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{ 
  ASSERT (p_cux != NULL);

  switch (plus) {
  case 1:
    switch (doppelpunkt) { /* v_6347 COND weil C504 COND ist */
    case 1:
      SETRETVAL (p_cux->v_6347, COND);
      break;
    case 2:
      SETRETVAL (p_cux->v_6345, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;

  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void doc_ini (void)
{
  p_doc = (struct s_doc_seg *) calloc (sizeof (struct s_doc_seg), 1);
  if (p_doc == NULL)
    fovdMallocError ();
}

int doc_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_doc != NULL);

  switch (plus) {
  case 1:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_doc->v_1001, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  case 2:
    switch (doppelpunkt) {
      case 4:
      SETRETVAL (p_doc->v_3453, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void dtm_ini (void)
{
  p_dtm = (struct s_dtm_seg *) calloc (sizeof (struct s_dtm_seg), 1);
  if (p_dtm == NULL)
    fovdMallocError ();
}

int dtm_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{ 
  ASSERT (p_dtm != NULL);

  switch (plus) {
  case 1:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_dtm->v_2005, MAND);
      break;
    case 2:
      SETRETVAL (p_dtm->v_2380, COND);
      break;
    case 3:
      SETRETVAL (p_dtm->v_2379, COND);
      break; 
    default:
      COLONERROR;
      break;
    }
    break;
  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void fii_ini (void)
{
  p_fii = (struct s_fii_seg *) calloc (sizeof (struct s_fii_seg), 1);
  if (p_fii == NULL)
    fovdMallocError ();
}

int fii_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_fii != NULL);

  switch (plus) {
  case 1:
    SETRETVAL (p_fii->v_3035, MAND);
    break;
  case 2:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_fii->v_3194, COND);
      break;
    case 2:
      SETRETVAL (p_fii->v_3192, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  case 3:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_fii->v_3433, COND);
      break;
    case 7:
      SETRETVAL (p_fii->v_3432, COND);
      break;
    case 8:
      SETRETVAL (p_fii->v_3436, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void ftx_ini (void)
{
  p_ftx = (struct s_ftx_seg *) calloc (sizeof (struct s_ftx_seg), 1);
  if (p_ftx == NULL)
    fovdMallocError ();
}

int ftx_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_ftx != NULL);

  switch (plus) {
  case 1:
    SETRETVAL (p_ftx->v_4451, MAND);
    break;
  case 3:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_ftx->v_4441, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  case 4:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_ftx->v_4440, COND);
      break;
    case 2:
      SETRETVAL (p_ftx->v_4440a, COND);
      break;
    case 3:
      SETRETVAL (p_ftx->v_4440b, COND);
      break;
    case 4:
      SETRETVAL (p_ftx->v_4440c, COND);
      break;
    case 5:
      SETRETVAL (p_ftx->v_4440d, COND);
      break;
    case 6:
      SETRETVAL (p_ftx->v_4440e, COND);
      break;

    default:
      COLONERROR;
      break;
    }
    break;
  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void imd_ini (void)
{
  p_imd = (struct s_imd_seg *) calloc (sizeof (struct s_imd_seg), 1);
  if (p_imd == NULL)
    fovdMallocError ();
}

int imd_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_imd != NULL);

  switch (plus) {
  case 2:
    SETRETVAL (p_imd->v_7081, COND);
    break;
  case 3:
    switch (doppelpunkt) { /* v_7009 COND weil C273 COND */
    case 1:
      SETRETVAL (p_imd->v_7009, COND);
      break;
    case 4:
      SETRETVAL (p_imd->v_7008, COND);
      break;
    case 5:
      SETRETVAL (p_imd->v_7008a, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;

  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void lin_ini (void)
{
  p_lin = (struct s_lin_seg *) calloc (sizeof (struct s_lin_seg), 1);
  if (p_lin == NULL)
    fovdMallocError ();
}

int lin_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_lin != NULL);

  switch (plus) {
  case 1:
    SETRETVAL (p_lin->v_1082, COND);
    break;
  case 3:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_lin->v_7140, COND);
      break;
    case 2:
      SETRETVAL (p_lin->v_7143, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  case 5:
    SETRETVAL (p_lin->v_1222, COND);
    break;

  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void loc_ini (void)
{
  p_loc = (struct s_loc_seg *) calloc (sizeof (struct s_loc_seg), 1);
  if (p_loc == NULL)
    fovdMallocError ();
}

int loc_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_loc != NULL);

  switch (plus) {
  case 1:
    SETRETVAL (p_loc->v_3227, MAND);
    break;
  case 3:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_loc->v_3223, COND);
      break;
    case 4:
      SETRETVAL (p_loc->v_3222, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;

  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void moa_ini (void)
{
  p_moa = (struct s_moa_seg *) calloc (sizeof (struct s_moa_seg), 1);
  if (p_moa == NULL)
    fovdMallocError ();
}

int moa_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_moa != NULL);

  switch (plus) {
  case 1:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_moa->v_5025, MAND);
      break;
    case 2:
      SETRETVAL (p_moa->v_5004, COND);
      break;
    case 3:
      SETRETVAL (p_moa->v_6345, COND);
      break;
    case 4:
      SETRETVAL (p_moa->v_6343, COND);
      break;
    case 5:
      SETRETVAL (p_moa->v_4405, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;

  default:
    PLUSERROR;
    break;
  }
  return (0);
}


void nad_ini (void)
{
  p_nad = (struct s_nad_seg *) calloc (sizeof (struct s_nad_seg), 1);
  if (p_nad == NULL)
    fovdMallocError ();
}

int nad_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_nad != NULL);

  switch (plus) {
  case 1:
    SETRETVAL (p_nad->v_3035, MAND);
    break;
  case 4:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_nad->v_3036, COND);
      break;
    case 2:
      SETRETVAL (p_nad->v_3036a, COND);
      break;
    case 3:
      SETRETVAL (p_nad->v_3036b, COND);
      break;
    case 4:
      SETRETVAL (p_nad->v_3036c, COND);
      break;
    case 5:
      SETRETVAL (p_nad->v_3036d, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  case 6:
    SETRETVAL (p_nad->v_3164, COND);
    break;
  case 8:
    SETRETVAL (p_nad->v_3251, COND);
    break;

  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void pat_ini (void)
{
  p_pat = (struct s_pat_seg *) calloc (sizeof (struct s_pat_seg), 1);
  if (p_pat == NULL)
    fovdMallocError ();
}

int pat_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_pat != NULL);

  switch (plus) {
  case 1:
    SETRETVAL (p_pat->v_4279, MAND);
    break;
  case 3:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_pat->v_2475, COND);
      break;
    case 2:
      SETRETVAL (p_pat->v_2009, COND);
      break;
    case 3:
      SETRETVAL (p_pat->v_2151, COND);
      break;
    case 4:
      SETRETVAL (p_pat->v_2152, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
 
  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void pcd_ini (void)
{
  p_pcd = (struct s_pcd_seg *) calloc (sizeof (struct s_pcd_seg), 1);
  if (p_pcd == NULL)
    fovdMallocError ();
}

int pcd_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_pcd != NULL);

  switch (plus) {
  case 1:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_pcd->v_5245, MAND);
      break;
    case 2:
      SETRETVAL (p_pcd->v_5482, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;

  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void pia_ini (void)
{
  p_pia = (struct s_pia_seg *) calloc (sizeof (struct s_pia_seg), 1);
  if (p_pia == NULL)
    fovdMallocError ();
}

int pia_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_pia != NULL);

  switch (plus) {
  case 1:
    SETRETVAL (p_pia->v_4347, MAND);
    break;

  case 2:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_pia->v_7140, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;

  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void pri_ini (void)
{
  p_pri = (struct s_pri_seg *) calloc (sizeof (struct s_pri_seg), 1);
  if (p_pri == NULL)
    fovdMallocError ();
}

int pri_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_pri != NULL);

  switch (plus) {
  case 1:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_pri->v_5125, COND);
      break;
    case 2:
      SETRETVAL (p_pri->v_5118, COND);
      break;
    case 3:
      SETRETVAL (p_pri->v_5375, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;

  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void qty_ini (void)
{
  p_qty = (struct s_qty_seg *) calloc (sizeof (struct s_qty_seg), 1);
  if (p_qty == NULL)
    fovdMallocError ();
}

int qty_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_qty != NULL);

  switch (plus) {
  case 1:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_qty->v_6063, MAND);
      break;
    case 2:
      SETRETVAL (p_qty->v_6060, MAND);
      break;
    case 3:
      SETRETVAL (p_qty->v_6411, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;

  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void rff_ini (void)
{
  p_rff = (struct s_rff_seg *) calloc (sizeof (struct s_rff_seg), 1);
  if (p_rff == NULL)
    fovdMallocError ();
}

int rff_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_rff != NULL);

  switch (plus) {
  case 1:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_rff->v_1153, MAND);
      break;
    case 2:
      SETRETVAL (p_rff->v_1154, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
   
  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void tax_ini (void)
{
  p_tax = (struct s_tax_seg *) calloc (sizeof (struct s_tax_seg), 1);
  if (p_tax == NULL)
    fovdMallocError ();
}

int tax_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_tax != NULL);

  switch (plus) {
  case 1:
    SETRETVAL (p_tax->v_5283, MAND);
    break;
  case 2:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_tax->v_5153, COND);
      break;
    case 4:
      SETRETVAL (p_tax->v_5152, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  case 5:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_tax->v_5279, COND);
      break;
    case 4:
      SETRETVAL (p_tax->v_5278, COND);
      break;
    case 5:
      SETRETVAL (p_tax->v_5273, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  case 6:
    SETRETVAL (p_tax->v_5305, COND);
    break;

  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void unh_ini (void)
{
  p_unh = (struct s_unh_seg *) calloc (sizeof (struct s_unh_seg), 1);
  if (p_unh == NULL)
    fovdMallocError ();
}

int unh_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_unh != NULL);

  switch (plus) {
  case 1:
    SETRETVAL (p_unh->v_0062, MAND);
    break;
  case 2:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_unh->v_0065, MAND);
      break;
    case 2:
      SETRETVAL (p_unh->v_0052, MAND);
      break;
    case 3:
      SETRETVAL (p_unh->v_0054, MAND);
      break;
    case 4:
      SETRETVAL (p_unh->v_0051, MAND);
      /*
       * Remember version and release as integers.
       * This is done when the new element is started.
       */
      p_unh->version = atoi (p_unh->v_0052);
      p_unh->release = atoi (p_unh->v_0054);

      break;
    case 5:
      SETRETVAL (p_unh->v_0057, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void uns_ini (void)
{
  p_uns = (struct s_uns_seg *) calloc (sizeof (struct s_uns_seg), 1);
  if (p_uns == NULL)
    fovdMallocError ();
}

int uns_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_uns != NULL);

  switch (plus) {
  case 1:
    SETRETVAL (p_uns->v_0081, MAND);
    break;
  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void unt_ini (void)
{
  p_unt = (struct s_unt_seg *) calloc (sizeof (struct s_unt_seg), 1);
  if (p_unt == NULL)
    fovdMallocError ();
}

int unt_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_unt != NULL);

  switch (plus) {
  case 1:
    SETRETVAL (p_unt->v_0074, MAND);
    break;
  case 2:
    SETRETVAL (p_unt->v_0062, COND);
    break;

  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void unz_ini (void)
{
  p_unz = (struct s_unz_seg *) calloc (sizeof (struct s_unz_seg), 1);
  if (p_unz == NULL)
    fovdMallocError ();
}

int unz_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_unz != NULL);

  switch (plus) {
  case 1:
    SETRETVAL (p_unz->v_0036, MAND);
    break;
  case 2:
    SETRETVAL (p_unz->v_0020, MAND);
    break;

  default:
    PLUSERROR;
    break;
  }
  return(0);
}


void xcd_ini (void)
{
  p_xcd = (struct s_xcd_seg *) calloc (sizeof (struct s_xcd_seg), 1);
  if (p_xcd == NULL)
    fovdMallocError ();
}

int xcd_func305 (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_xcd != NULL);

  switch(plus) {
  case 1:
    SETRETVAL (p_xcd->v_X001, MAND);
    break;
  case 2:
    SETRETVAL (p_xcd->v_X002, MAND);
    break;
  case 3:
    SETRETVAL (p_xcd->v_X003, MAND);
    break;
  case 4:
    SETRETVAL (p_xcd->v_X004, MAND);
    break;
  case 5:
    SETRETVAL (p_xcd->v_X005, MAND);
    break;
  case 6:
    SETRETVAL (p_xcd->v_X006, MAND);
    break;
  case 7:
    SETRETVAL (p_xcd->v_X007, MAND);
    break;
  case 8:
    SETRETVAL (p_xcd->v_X008, MAND);
    break;
  case 9:
    SETRETVAL (p_xcd->v_X009, MAND);
    break;
  case 10:
    SETRETVAL (p_xcd->v_X010, MAND);
    break;
  case 11:
    SETRETVAL (p_xcd->v_6411, MAND);
    break;
  case 12:
    SETRETVAL (p_xcd->v_X011, MAND);
    break;
  case 13:
    SETRETVAL (p_xcd->v_X012, MAND);
    break;
  case 14:
    SETRETVAL (p_xcd->v_5004c, COND);
    break;
  case 15:
    SETRETVAL (p_xcd->v_6345c, COND);
    break;
  case 16:
    SETRETVAL (p_xcd->v_6343c, COND);
    break;
  case 17:
    SETRETVAL (p_xcd->v_5004, COND);
    break;
  case 18:
    SETRETVAL (p_xcd->v_6345, COND);
    break;
  case 19:
    SETRETVAL (p_xcd->v_6343, COND);
    break;
  case 20:
    SETRETVAL (p_xcd->v_X013, MAND);
    break;
  case 21:
    SETRETVAL (p_xcd->v_X014, COND);
    break;
  case 22:
    SETRETVAL (p_xcd->v_X015, COND);
    break;
  case 23:
    SETRETVAL (p_xcd->v_X016, COND);
    break;
  case 24:
    SETRETVAL (p_xcd->v_X017, COND);
    break;
  case 25:
    SETRETVAL (p_xcd->v_X018, MAND);
    break;
  case 26:
    SETRETVAL (p_xcd->v_X019, MAND);
    break;
  case 27:
    SETRETVAL (p_xcd->v_X020, MAND);
    break;
  case 28:
    SETRETVAL (p_xcd->v_X021, COND);
    break;
  case 29:
    SETRETVAL (p_xcd->v_X022, MAND);
    break;
  case 30:
    SETRETVAL (p_xcd->v_X023, MAND);
    break;
  case 31:
    SETRETVAL (p_xcd->v_X024, COND);
    break;
  case 32:
    SETRETVAL (p_xcd->v_X025, COND);
    break;
  case 33:
    SETRETVAL (p_xcd->v_X026, MAND);
    break;
  case 34:
    SETRETVAL (p_xcd->v_X027, COND);
    break;
  case 35:
    SETRETVAL (p_xcd->v_X028, MAND);
    break;
  case 36:
    SETRETVAL (p_xcd->v_X029, COND);
    break;

#ifdef US_TIMM_LAYOUT
  case 37:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_xcd->v_X030, COND);
      break;
    case 2:
      SETRETVAL (p_xcd->v_X031, COND);	
      break;
    case 3:
      SETRETVAL (p_xcd->v_X032, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  case 38:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_xcd->v_X033, COND);
      break;
    case 2:
      SETRETVAL (p_xcd->v_X034, COND);
      break;
    case 3:
      SETRETVAL (p_xcd->v_X035, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  case 39:
    SETRETVAL (p_xcd->v_X036, COND);
    break;
  case 40:
    SETRETVAL (p_xcd->v_X037, COND);
    break;
  case 41:
    SETRETVAL (p_xcd->v_X038, COND);
    break;
  case 42:
    SETRETVAL (p_xcd->v_X039, COND);
    break;
  case 43:
    SETRETVAL (p_xcd->v_X040, COND);
    break;
  case 44:
    SETRETVAL (p_xcd->v_X041, COND);
    break;
#endif /* US_TIMM_LAYOUT */

  case 45:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_xcd->v_5004a, COND);
      break;
    case 2:
      SETRETVAL (p_xcd->v_6345a, COND);
      break;
    case 3:
      SETRETVAL (p_xcd->v_6343a, COND);
      break;
    case 4:
      SETRETVAL (p_xcd->v_5004b, COND);
      break;
    case 5:
      SETRETVAL (p_xcd->v_6345b, COND);
      break;
    case 6:
      SETRETVAL (p_xcd->v_6343b, COND);
      break;
    case 7:	
      SETRETVAL (p_xcd->v_X042,  COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  case 46:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_xcd->v_X043, COND);
      break;
    case 2:
      SETRETVAL (p_xcd->v_X044, COND);
      break;
    case 3:
      SETRETVAL (p_xcd->v_X045, COND);
      break;
    case 4:
      SETRETVAL (p_xcd->v_X046, COND);	
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  case 47:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_xcd->v_X047, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  case 48:
    switch (doppelpunkt) {	
    case 1:
      SETRETVAL (p_xcd->v_X048, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;

  default:
    PLUSERROR;
    break;
  }
  return(0);
}


/*
 * XCD for TIMM-Version 209 - there are too many differences for
 * a common routine :-(
 */
 
int xcd_func209 (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_xcd != NULL);

  switch (plus) {
  case 1:
    SETRETVAL (p_xcd->v_X001, MAND);
    break;
  case 2:
    SETRETVAL (p_xcd->v_X002, MAND);
    break;
  case 3:
    SETRETVAL (p_xcd->v_X003, MAND); 
    break;
  case 4:
    SETRETVAL (p_xcd->v_X004, MAND);
    break;
  case 5:
    SETRETVAL (p_xcd->v_X005, MAND);
    break;
  case 6:
    SETRETVAL (p_xcd->v_X006, MAND);
    break;
  case 7:
    SETRETVAL (p_xcd->v_6411, MAND);
    break;
  case 8:
    SETRETVAL (p_xcd->v_X007, MAND);
    break;
  case 9:
    SETRETVAL (p_xcd->v_5004, COND);
    break;
  case 10:
    SETRETVAL (p_xcd->v_6345, COND);
    break;
  case 11:
    SETRETVAL (p_xcd->v_6343, COND);
    break;
  case 12:
    SETRETVAL (p_xcd->v_X008, MAND);
    break;
  case 13:
    SETRETVAL (p_xcd->v_X009, MAND);
    break;
  case 14:
    SETRETVAL (p_xcd->v_X010, MAND);
    break;
  case 15:
    SETRETVAL (p_xcd->v_X011, MAND);
    break;
  case 16:
    SETRETVAL (p_xcd->v_X012, MAND);
    break;
  case 17:
    SETRETVAL (p_xcd->v_X013, MAND);
    break;
  case 18:
    SETRETVAL (p_xcd->v_X014, MAND);
    break;
  case 19:
    SETRETVAL (p_xcd->v_X015, MAND);
    break;
  case 20:
    SETRETVAL (p_xcd->v_X016, MAND);
    break;
  case 21:
    SETRETVAL (p_xcd->v_X017, MAND);
    break;
  case 22:
    SETRETVAL (p_xcd->v_X017a, COND); 
    break;
  case 23:
    SETRETVAL (p_xcd->v_X018, MAND);
    break;
  case 24:
    SETRETVAL (p_xcd->v_X019, COND);
    break;
  case 25:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_xcd->v_5004a, COND);
      break;
    case 2:
      SETRETVAL (p_xcd->v_6345a, COND);
      break;
    case 3:
      SETRETVAL (p_xcd->v_6343a, COND);
      break;
    case 4:
      SETRETVAL (p_xcd->v_5004b, COND);
      break;
    case 5:
      SETRETVAL (p_xcd->v_6345b, COND);
      break;
    case 6:
      SETRETVAL (p_xcd->v_6343b, COND);
      break;
    case 7:
      SETRETVAL (p_xcd->v_X024, COND);
      break;
    default:
      COLONERROR;
      break;
    }
  break;
  case 26:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_xcd->v_X020, COND);
      break;
    case 2:
      SETRETVAL (p_xcd->v_X021, COND);
      break;
    case 3:
      SETRETVAL (p_xcd->v_X022, COND);
      break;
    case 4:
      SETRETVAL (p_xcd->v_X023, COND);
      break;
    case 5:
      SETRETVAL (p_xcd->v_X024a, COND);
      break;
    default:
      COLONERROR;
      break;
    }
  break;
  case 27:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_xcd->v_X025, COND);
      break;
    default:
      COLONERROR;
      break;
    }
  break;
  case 28:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_xcd->v_X026, COND);
      break;
    default:
      COLONERROR;
      break;
    }
  break;

  default:
    PLUSERROR;
    break;
  }
  return(0);
}


/*
 * XCD for TIMM-Version 210 - there are too many differences for
 * a common routine :-(
 */

int xcd_func210 (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_xcd != NULL);

  switch (plus) {
  case 1:
    SETRETVAL (p_xcd->v_X001, MAND);
    break;
  case 2:
    SETRETVAL (p_xcd->v_X002, MAND);
    break;
  case 3:
    SETRETVAL (p_xcd->v_X003, MAND);
    break;
  case 4:
    SETRETVAL (p_xcd->v_X004, MAND);
    break;
  case 5:
    SETRETVAL (p_xcd->v_X005, MAND);
    break;
  case 6:
    SETRETVAL (p_xcd->v_X006, MAND);
    break;
  case 7:
    SETRETVAL (p_xcd->v_X006a, MAND);
    break;
  case 8:
    SETRETVAL (p_xcd->v_6411, MAND);
    break;
  case 9:
    SETRETVAL (p_xcd->v_X007, MAND);
    break;
  case 10:
    SETRETVAL (p_xcd->v_5004, COND);
    break;
  case 11:
    SETRETVAL (p_xcd->v_6345, COND);
    break;
  case 12:
    SETRETVAL (p_xcd->v_6343, COND);
    break;
  case 13:
    SETRETVAL (p_xcd->v_X008, MAND);
    break;
  case 14:
    SETRETVAL (p_xcd->v_X009, MAND);
    break;
  case 15:
    SETRETVAL (p_xcd->v_X009a, MAND);
    break;
  case 16:
    SETRETVAL (p_xcd->v_X010, MAND);
    break;
  case 17:
    SETRETVAL (p_xcd->v_X011, MAND);
    break;
  case 18:
    SETRETVAL (p_xcd->v_X012, MAND);
    break;
  case 19:
    SETRETVAL (p_xcd->v_X013, MAND);
    break;
  case 20:
    SETRETVAL (p_xcd->v_X014, MAND);
    break;
  case 21:
    SETRETVAL (p_xcd->v_X015, MAND);
    break;
  case 22:
    SETRETVAL (p_xcd->v_X016, MAND);
    break;
  case 23:
    SETRETVAL (p_xcd->v_X017, MAND);
    break;
  case 24:
    SETRETVAL (p_xcd->v_X017a, COND);
    break;
  case 25:
    SETRETVAL (p_xcd->v_X018, MAND);
    break;
  case 26:
    SETRETVAL (p_xcd->v_X019, COND);
    break;
  case 27:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_xcd->v_5004a, COND);
      break;
    case 2:
      SETRETVAL (p_xcd->v_6345a, COND);
      break;
    case 3:
      SETRETVAL (p_xcd->v_6343a, COND);
      break;
    case 4:
      SETRETVAL (p_xcd->v_5004b, COND);
      break;
    case 5:
      SETRETVAL (p_xcd->v_6345b, COND);
      break;
    case 6:
      SETRETVAL (p_xcd->v_6343b, COND);
      break;
    case 7:
      SETRETVAL (p_xcd->v_X024, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  case 28:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_xcd->v_X020, COND);
      break;
    case 2:
      SETRETVAL (p_xcd->v_X021, COND);
      break;
    case 3:
      SETRETVAL (p_xcd->v_X023, COND);
      break;
    case 4:
      SETRETVAL (p_xcd->v_X024a, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  case 29:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_xcd->v_X025, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  case 30:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_xcd->v_X026, COND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;

  default:
    PLUSERROR;
    break;
  }
  return(0);
}

/*
 * Common XCD caller function
 */

int xcd_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  switch (p_inter->timm->unh->version) {
  case 209:
    return (xcd_func209 (plus, doppelpunkt, ppBuf, pLen, fMand));
    break;
  case 210:
    return (xcd_func210 (plus, doppelpunkt, ppBuf, pLen, fMand));
    break;
  case 305:
  case 306:
  case 307:
    /* FALLTHROUGH */
    /*
     * Version is checked before !!
     */
  default:
    return (xcd_func305 (plus, doppelpunkt, ppBuf, pLen, fMand));
    break;
  }
}

void unb_ini (void)
{
  p_unb = (struct s_unb_seg *) calloc (sizeof (struct s_unb_seg), 1);
  if (p_unb == NULL)
    fovdMallocError ();
}

int unb_func (int plus, int doppelpunkt, char **ppBuf, int *pLen, BOOL *fMand)
{
  ASSERT (p_unb != NULL);

  switch (plus) {
  case 1:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_unb->v_0001, MAND);
      break;
    case 2:
      SETRETVAL (p_unb->v_0002, MAND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  case 2:
    SETRETVAL (p_unb->v_0004, MAND);
    break;
  case 3:
    SETRETVAL (p_unb->v_0010, MAND);
    break;
  case 4:
    switch (doppelpunkt) {
    case 1:
      SETRETVAL (p_unb->v_0017, MAND);
      break;
    case 2:
      SETRETVAL (p_unb->v_0019, MAND);
      break;
    default:
      COLONERROR;
      break;
    }
    break;
  case 5:
    SETRETVAL (p_unb->v_0020, MAND);
    pszCustId = p_unb->v_0010;	/* to remember customer id */
    break;
  default:
    PLUSERROR;
    break;
  }

  return (0);
}

#define SETTOK(a,b,c)	((a)<<16)+((b)<<8)+(c)

struct stTOKENINFO {
  char			*szName;
  int			iTok;
  unsigned long		lToken;
  void 			(*pIni)(void);
  int 			(*pFunc)(int, int, char **, int *, BOOL *);
} astToken[] = {
  {"ALC", ALC_SEGMENT, SETTOK ('A','L','C'), alc_ini, alc_func},
  {"BGM", BGM_SEGMENT, SETTOK ('B','G','M'), bgm_ini, bgm_func},
  {"CNT", CNT_SEGMENT, SETTOK ('C','N','T'), cnt_ini, cnt_func},
  {"COM", COM_SEGMENT, SETTOK ('C','O','M'), com_ini, com_func},
  {"CTA", CTA_SEGMENT, SETTOK ('C','T','A'), cta_ini, cta_func},
  {"CUX", CUX_SEGMENT, SETTOK ('C','U','X'), cux_ini, cux_func},
  {"DOC", DOC_SEGMENT, SETTOK ('D','O','C'), doc_ini, doc_func},
  {"DTM", DTM_SEGMENT, SETTOK ('D','T','M'), dtm_ini, dtm_func},
  {"FII", FII_SEGMENT, SETTOK ('F','I','I'), fii_ini, fii_func},
  {"FTX", FTX_SEGMENT, SETTOK ('F','T','X'), ftx_ini, ftx_func},
  {"IMD", IMD_SEGMENT, SETTOK ('I','M','D'), imd_ini, imd_func},
  {"LIN", LIN_SEGMENT, SETTOK ('L','I','N'), lin_ini, lin_func},
  {"LOC", LOC_SEGMENT, SETTOK ('L','O','C'), loc_ini, loc_func},
  {"MOA", MOA_SEGMENT, SETTOK ('M','O','A'), moa_ini, moa_func},
  {"NAD", NAD_SEGMENT, SETTOK ('N','A','D'), nad_ini, nad_func},
  {"PAT", PAT_SEGMENT, SETTOK ('P','A','T'), pat_ini, pat_func},
  {"PCD", PCD_SEGMENT, SETTOK ('P','C','D'), pcd_ini, pcd_func},
  {"PIA", PIA_SEGMENT, SETTOK ('P','I','A'), pia_ini, pia_func},
  {"PRI", PRI_SEGMENT, SETTOK ('P','R','I'), pri_ini, pri_func},
  {"QTY", QTY_SEGMENT, SETTOK ('Q','T','Y'), qty_ini, qty_func},
  {"RFF", RFF_SEGMENT, SETTOK ('R','F','F'), rff_ini, rff_func},
  {"TAX", TAX_SEGMENT, SETTOK ('T','A','X'), tax_ini, tax_func},
  {"UNB", UNB_SEGMENT, SETTOK ('U','N','B'), unb_ini, unb_func},
  {"UNH", UNH_SEGMENT, SETTOK ('U','N','H'), unh_ini, unh_func},
  {"UNS", UNS_SEGMENT, SETTOK ('U','N','S'), uns_ini, uns_func},
  {"UNT", UNT_SEGMENT, SETTOK ('U','N','T'), unt_ini, unt_func},
  {"UNZ", UNZ_SEGMENT, SETTOK ('U','N','Z'), unz_ini, unz_func},
  {"XCD", XCD_SEGMENT, SETTOK ('X','C','D'), xcd_ini, xcd_func}
};

#define NRTOKEN (sizeof (astToken) / sizeof (struct stTOKENINFO))

/******************************************************************************
 * fpGetDatPtr
 *
 * DESCRIPTION:
 * fetch a pointer into a segment
 *
 * PARAMETERS:
 *  int	    	iSeg		- index to segment table
 *  int		iPlus		- number of plus signs read
 *  int		iColon		- number of colons read
 *  int		*piLen		- returned length of buffer
 *  BOOL	*pfMand		- return: TRUE - mandatory element
 *
 * RETURNS:
 *  pointer to buffer
 ******************************************************************************
 */
char *fpGetDatPtr (int iSeg, int iPlus, int iColon, int *piLen, BOOL *pfMand)
{
  char 	*ppBuf;

  astToken[iSeg].pFunc (iPlus, iColon, &ppBuf, piLen, pfMand);

  return (ppBuf);
}


/******************************************************************************
 * fofCheckMand
 *
 * DESCRIPTION:
 * check if a mandatory element exists
 *
 * PARAMETERS:
 *  int	    	iSeg		- index to segment table
 *  int		iPlus		- number of plus signs read
 *  int		iColon		- number of colons read
 *
 * RETURNS:
 *  TRUE if mandatory element exists or element is not mandatory
 ******************************************************************************
 */
BOOL fofCheckMand (int iSeg, int iPlus, int iColon)
{
  char	*pPtr;
  int	iMax;
  BOOL	fMand;

  pPtr = fpGetDatPtr (iSeg, iPlus, iColon, &iMax, &fMand);

  if (fMand && (*pPtr == '\0')) {
    if (iColon > 1) {
      sprintf (szErr,
	       "PARSER (%s): missing mandatory element in segment %s, nr. %d (%d. plus, %d. colon)",
	       pszCustId, SegName, SegNr, iPlus, iColon - 1);
    } else {
      sprintf (szErr,
	       "PARSER (%s): missing mandatory element in segment %s, nr. %d (%d. plus)",
	       pszCustId, SegName, SegNr, iPlus);
    }
    return (FALSE);
  }
  return (TRUE);
}


/******************************************************************************
 * fpBuildSegment
 *
 * DESCRIPTION:
 * build a segment from the input
 *
 * PARAMETERS:
 *  char    *pBuf		- pointer to buffer
 *  int	    iSeg		- index to segment table
 *
 * RETURNS:
 *  pointer to rest of string
 ******************************************************************************
 */
char *fpBuildSegment (char *pBuf, int iSeg)
{
  char 	*pTmp;
  char 	*pCurPtr;
  int	iColon;
  int	iPlus;
  int	iCurMax;
  BOOL	fStText;
  BOOL	fMand;			/* mandatory element */
  int	iLastSeg;
  int	iLastColon;
  int	iLastPlus;
  char	*pLastPtr;

  /*
   * Call the initializing function
   */
  astToken[iSeg].pIni ();

  iLastSeg = -1;
  iPlus  = 1;
  iColon = 1;
  fStText = TRUE;		/* start new text */
  fMand	 = FALSE;

  /*
   * Just set it to dummy string
   */
  pCurPtr = dummy;
  iCurMax = sizeof (dummy);

  pTmp = pBuf;

  while (*pTmp) {

    switch (*pTmp) {

    case '+':			/* a plus sign */
      *pCurPtr = '\0';		/* terminate buffer */
      if (fStText) {
        (void) fofCheckMand (iSeg, iPlus, iColon);
      }
      iPlus++;			/* set the values new */
      iColon = 1;
      fStText = TRUE;		/* start new text */
      break;
      
    case ':':			/* a colon */
      *pCurPtr = '\0';		/* terminate buffer */
      if (fStText) {
        (void) fofCheckMand (iSeg, iPlus, iColon);
      }
      iColon++;
      fStText = TRUE;		/* start new text */
      break;

    case '\'':			/* end of the segment */
      *pCurPtr = '\0';		/* terminate buffer */
      if (fStText) {
        (void) fofCheckMand (iSeg, iPlus, iColon);
      }
      return (pTmp);

      
    case '?':			/* the Escape - take next literal */
      pTmp++;
      if (*pTmp == '\0') {
        pTmp--;
        break;
      }
      

      /* FALLTHROUGH */
    default:			/* normal copying... */
      if (fStText) {
#ifdef DEBUG
        /* ignore single underscores in debug mode */
        if ((*pTmp == '_')	&& ((pTmp[1] == ':')	|| (pTmp[1] == '+') || (pTmp[1] == '\''))) {
          break;
        }
#endif
        pCurPtr = fpGetDatPtr (iSeg, iPlus, iColon, &iCurMax, &fMand);
        pLastPtr = pCurPtr;
        iLastColon = iColon;
        iLastPlus  = iPlus;
        fStText = FALSE;
      }
      if (iCurMax > 0) {
        *pCurPtr++ = *pTmp;
        iCurMax--;
      } 
      else 
        {
          if (iLastSeg != SegNr) {
            /* do not complain about CR and LF */
            if ((*pTmp != '\r') && (*pTmp != '\n')) {
              *pCurPtr = '\0';
              sprintf (szErr,
                       "PARSER (%s):\nTruncated element in Segment %s, Nr. %d "
                       "(%d '+', %d ':', '%s%c')",
                       pszCustId, SegName, SegNr, iLastPlus, iLastColon, pLastPtr, *pTmp);
              printf (szErr);
              iLastSeg = SegNr;
            }
          }
        }
      break;
    }
    pTmp++;
  }
  return (pTmp);
}


/******************************************************************************
 * yylex
 *
 * DESCRIPTION:
 * my private lexer function
 *
 * PARAMETERS:
 *  - none -
 *
 * RETURNS:
 *  token
 ******************************************************************************
 */
int yylex ()
{
  register char	*pTmp, *pStart;
  unsigned long	lTok;
  int 		i;

  pTmp = bgh_input_ptr;

  if ((pTmp[0] == '\0')	||
      (pTmp[1] == '\0') ||
      (pTmp[2] == '\0')) {
    return (0);
  }
  pTmp += 3;

  while (pTmp) {

    pTmp = strchr (pTmp, '+');

    if (pTmp == NULL) {
      return (0);
      break;
    }

    pStart = pTmp - 3;
    pTmp++;

    /* compute long token value */
    lTok = SETTOK (pStart[0], pStart[1], pStart[2]);

    for (i = 0; i < (sizeof (astToken) / sizeof (struct stTOKENINFO)); i++) {

      if (lTok == astToken[i].lToken) {
	SegName = astToken[i].szName;
	SegNr++;
#ifdef DEBUG
	printf ("found: %c%c%c\n", pStart[0], pStart[1], pStart[2]);
#endif
	break;
      }
    }
    if (i == (sizeof (astToken) / sizeof (struct stTOKENINFO))) {
      sprintf (szErr, "PARSER (%s): Unknown Token (%c%c%c%c%c), Segment Nr.: %d\n",
               pszCustId, pStart[0], pStart[1], pStart[2], pStart[3], pStart[4], SegNr);
      return (0);
    } else {
      /* here we have it - now fill a buffer */
      bgh_input_ptr = fpBuildSegment (pTmp, i);

      return (astToken[i].iTok);
    }
  }

  return (0);
}


/******************************************************************************
 * fofSegError
 *
 * DESCRIPTION:
 * Print an error message about wrong segment
 *
 * PARAMETERS:
 * int		iSeg		- segment
 * int		iExp		- expected Segment
 *
 * RETURNS:
 * TRUE if error
 ******************************************************************************
 */
BOOL fofSegError (int iSeg, int iExp)
{
  if (iSeg == iExp) {
    return (FALSE);
  }

  if (iSeg == SEGMENT_ERROR) {
    /* return without complaint */
    return (TRUE);
  }

  if (iSeg >= (sizeof (astToken) / sizeof (struct stTOKENINFO))) {
    fprintf (stderr, "Illegal segment nr: %d expected: %d\n", iSeg, iExp);
  } else {
    fprintf (stderr, "Wrong segment: %s expected: %s\n",
	     astToken[iSeg].szName, astToken[iExp].szName);
  }
  return (TRUE);
}


/******************************************************************************
 * foiGetGroup99
 *
 * DESCRIPTION:
 * Get Group 99
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * next token
 ******************************************************************************
 */
int foiGetGroup99 (int iToken)
{
    int		liTok;

    if (fofSegError (iToken, XCD_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    *pp_g99 = (struct s_group_99*) timm_malloc (sizeof (struct s_group_99));
    p_g99   = *pp_g99;

    p_g99->xcd = p_xcd;
    pp_g99  = &(p_g99->g_99_next);

    liTok = yylex ();			/* Get next segment */

    return (liTok);
}


/******************************************************************************
 * foiGetGroup47
 *
 * DESCRIPTION:
 * Get Group 47
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * next token
 ******************************************************************************
 */
int foiGetGroup47 (int iToken)
{
    int		liTok;

    if (fofSegError (iToken, TAX_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    *pp_g47 = (struct s_group_47*) timm_malloc (sizeof (struct s_group_47));
    p_g47   = *pp_g47;

    pp_moa = &(p_g47->moa);

    p_g47->tax = p_tax;

    liTok = yylex ();			/* Get next segment */

    /*
     * Get none or more MOA segments
     */
    while (liTok == MOA_SEGMENT) {
	*pp_moa = p_moa;
	pp_moa  = &(p_moa->moa_next);
	liTok = yylex ();		/* Get next segment */
    }

    pp_g47  = &(p_g47->g_47_next);

    return (liTok);
}


/******************************************************************************
 * foiGetGroup45
 *
 * DESCRIPTION:
 * Get Group 45
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * next token
 ******************************************************************************
 */
int foiGetGroup45 (int iToken)
{
    int		liTok;

    if (fofSegError (iToken, MOA_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    *pp_g45 = (struct s_group_45*) timm_malloc (sizeof (struct s_group_45));
    p_g45   = *pp_g45;

    p_g45->moa = p_moa;
    pp_g45  = &(p_g45->g_45_next);

    liTok = yylex ();			/* Get next segment */

    return (liTok);
}


/******************************************************************************
 * foiGetGroup40
 *
 * DESCRIPTION:
 * Get Group 40
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * next token
 ******************************************************************************
 */
int foiGetGroup40 (int iToken)
{
    int		liTok;

    if (fofSegError (iToken, TAX_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    *pp_g40 = (struct s_group_40*) timm_malloc (sizeof (struct s_group_40));
    p_g40   = *pp_g40;

    pp_moa = &(p_g40->moa);

    p_g40->tax = p_tax;

    liTok = yylex ();			/* Get next segment */

    /*
     * Get none or more MOA segments
     */
    while (liTok == MOA_SEGMENT) {
	*pp_moa = p_moa;
	pp_moa  = &(p_moa->moa_next);
	liTok = yylex ();		/* Get next segment */
    }

    pp_g40  = &(p_g40->g_40_next);

    return (liTok);
}


/******************************************************************************
 * foiGetGroup38
 *
 * DESCRIPTION:
 * Get Group 38
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * next token
 ******************************************************************************
 */
int foiGetGroup38 (int iToken)
{
    int		liTok;

    if (fofSegError (iToken, MOA_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    *pp_g38 = (struct s_group_38*) timm_malloc (sizeof (struct s_group_38));
    p_g38   = *pp_g38;

    p_g38->moa = p_moa;
    pp_g38  = &(p_g38->g_38_next);

    liTok = yylex ();			/* Get next segment */

    return (liTok);
}


/******************************************************************************
 * foiGetGroup37
 *
 * DESCRIPTION:
 * Get Group 37
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * next token
 ******************************************************************************
 */
int foiGetGroup37 (int iToken)
{
    int		liTok;

    if (fofSegError (iToken, PCD_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    *pp_g37 = (struct s_group_37*) timm_malloc (sizeof (struct s_group_37));
    p_g37   = *pp_g37;

    p_g37->pcd = p_pcd;

    liTok = yylex ();			/* Get next segment */

    return (liTok);
}


/******************************************************************************
 * foiGetGroup35
 *
 * DESCRIPTION:
 * Get Group 35
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * next token
 ******************************************************************************
 */
int foiGetGroup35 (int iToken)
{
    int		liTok;

    if (fofSegError (iToken, ALC_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    *pp_g35 = (struct s_group_35*) timm_malloc (sizeof (struct s_group_35));
    p_g35   = *pp_g35;

    p_g35->alc = p_alc;

    pp_g37  = &(p_g35->g_37);
    pp_g38  = &(p_g35->g_38);
    pp_g40  = &(p_g35->g_40);

    liTok = yylex ();			/* Get next segment */

    /* Group 37 now conditionally just once */
    if (liTok == PCD_SEGMENT) {
	liTok = foiGetGroup37 (liTok);
    }

    /* Group 38 now conditionally */
    while (liTok == MOA_SEGMENT) {
	liTok = foiGetGroup38 (liTok);
    }

    /* Group 40 now conditionally */
    while (liTok == TAX_SEGMENT) {
	liTok = foiGetGroup40 (liTok);
    }

    pp_g35  = &(p_g35->g_35_next);

    return (liTok);
}


/******************************************************************************
 * foiGetGroup31
 *
 * DESCRIPTION:
 * Get Group 31
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * next token
 ******************************************************************************
 */
int foiGetGroup31 (int iToken)
{
    int		liTok;

    if (fofSegError (iToken, NAD_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    *pp_g31 = (struct s_group_31*) timm_malloc (sizeof (struct s_group_31));
    p_g31   = *pp_g31;

    pp_loc = &(p_g31->loc);

    p_g31->nad = p_nad;

    liTok = yylex ();			/* Get next segment */

    /*
     * Get none or more LOC segments
     */
    while (liTok == LOC_SEGMENT) {
	*pp_loc = p_loc;
	pp_loc  = &(p_loc->loc_next);
	liTok = yylex ();		/* Get next segment */
    }

    pp_g31  = &(p_g31->g_31_next);

    return (liTok);
}


/******************************************************************************
 * foiGetGroup30
 *
 * DESCRIPTION:
 * Get Group 30
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * next token
 ******************************************************************************
 */
int foiGetGroup30 (int iToken)
{
    int		liTok;

    if (fofSegError (iToken, TAX_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    *pp_g30 = (struct s_group_30*) timm_malloc (sizeof (struct s_group_30));
    p_g30   = *pp_g30;

    pp_moa = &(p_g30->moa);

    p_g30->tax = p_tax;

    liTok = yylex ();			/* Get next segment */

    /*
     * Get none or more MOA segments
     */
    while (liTok == MOA_SEGMENT) {
	*pp_moa = p_moa;
	pp_moa  = &(p_moa->moa_next);
	liTok = yylex ();		/* Get next segment */
    }

    pp_g30  = &(p_g30->g_30_next);

    return (liTok);
}


/******************************************************************************
 * foiGetGroup26
 *
 * DESCRIPTION:
 * Get Group 26
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * next token
 ******************************************************************************
 */
int foiGetGroup26 (int iToken)
{
    int		liTok;

    if (fofSegError (iToken, RFF_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    *pp_g26 = (struct s_group_26*) timm_malloc (sizeof (struct s_group_26));
    p_g26   = *pp_g26;

    p_g26->rff = p_rff;
    pp_g26  = &(p_g26->g_26_next);

    liTok = yylex ();			/* Get next segment */

    return (liTok);
}


/******************************************************************************
 * foiGetGroup25
 *
 * DESCRIPTION:
 * Get Group 25
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * next token
 ******************************************************************************
 */
int foiGetGroup25 (int iToken)
{
    int		liTok;

    if (fofSegError (iToken, PRI_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    *pp_g25 = (struct s_group_25*) timm_malloc (sizeof (struct s_group_25));
    p_g25   = *pp_g25;

    p_g25->pri = p_pri;
    pp_g25  = &(p_g25->g_25_next);

    liTok = yylex ();			/* Get next segment */

    return (liTok);
}


/******************************************************************************
 * foiGetGroup23
 *
 * DESCRIPTION:
 * Get Group 23
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * next token
 ******************************************************************************
 */
int foiGetGroup23 (int iToken)
{
    int		liTok;

    if (fofSegError (iToken, MOA_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    *pp_g23 = (struct s_group_23*) timm_malloc (sizeof (struct s_group_23));
    p_g23   = *pp_g23;

    p_g23->moa = p_moa;
    pp_g23  = &(p_g23->g_23_next);

    liTok = yylex ();			/* Get next segment */

    return (liTok);
}


/******************************************************************************
 * foiGetGroup22
 *
 * DESCRIPTION:
 * Get Group 22
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * next token
 ******************************************************************************
 */
int foiGetGroup22 (int iToken)
{
    int		liTok;

    if (fofSegError (iToken, LIN_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    *pp_g22 = (struct s_group_22*) timm_malloc (sizeof (struct s_group_22));
    p_g22 = *pp_g22;

    p_g22->lin = p_lin;

    pp_pia = &(p_g22->pia);
    pp_imd = &(p_g22->imd);
    pp_qty = &(p_g22->qty);
    pp_dtm = &(p_g22->dtm);
    pp_ftx = &(p_g22->ftx);
    pp_g23 = &(p_g22->g_23);
    pp_g25 = &(p_g22->g_25);
    pp_g26 = &(p_g22->g_26);
    pp_g30 = &(p_g22->g_30);
    pp_g31 = &(p_g22->g_31);
    pp_g35 = &(p_g22->g_35);
    pp_g99 = &(p_g22->g_99);

    liTok = yylex ();			/* Get next segment */

    /*
     * Get none or more PIA segments
     */
    while (liTok == PIA_SEGMENT) {
	*pp_pia = p_pia;
	pp_pia  = &(p_pia->pia_next);
	liTok = yylex ();		/* Get next segment */
    }

    /*
     * Get none or more IMD segments
     */
    while (liTok == IMD_SEGMENT) {
	*pp_imd = p_imd;
	pp_imd  = &(p_imd->imd_next);
	liTok = yylex ();		/* Get next segment */
    }

    /*
     * Get none or more QTY segments
     */
    while (liTok == QTY_SEGMENT) {
	*pp_qty = p_qty;
	pp_qty  = &(p_qty->qty_next);
	liTok = yylex ();		/* Get next segment */
    }

    /*
     * Get none or more DTM segments
     */
    while (liTok == DTM_SEGMENT) {
	*pp_dtm = p_dtm;
	pp_dtm  = &(p_dtm->dtm_next);
	liTok = yylex ();		/* Get next segment */
    }

    /*
     * Get none or more FTX segments
     */
    while (liTok == FTX_SEGMENT) {
	*pp_ftx = p_ftx;
	pp_ftx  = &(p_ftx->ftx_next);
	liTok = yylex ();		/* Get next segment */
    }

    /* Group 23 now conditionally */
    while (liTok == MOA_SEGMENT) {
	liTok = foiGetGroup23 (liTok);
    }

    /* Group 25 now conditionally */
    while (liTok == PRI_SEGMENT) {
	liTok = foiGetGroup25 (liTok);
    }

    /* Group 26 now conditionally */
    while (liTok == RFF_SEGMENT) {
	liTok = foiGetGroup26 (liTok);
    }

    /* Group 30 now conditionally */
    while (liTok == TAX_SEGMENT) {
	liTok = foiGetGroup30 (liTok);
    }

    /* Group 31 now conditionally */
    while (liTok == NAD_SEGMENT) {
	liTok = foiGetGroup31 (liTok);
    }

    /* Group 35 now conditionally */
    while (liTok == ALC_SEGMENT) {
	liTok = foiGetGroup35 (liTok);
    }

    /* Group 99 now conditionally */
    while (liTok == XCD_SEGMENT) {
	liTok = foiGetGroup99 (liTok);
    }

    pp_g22 = &(p_g22->g_22_next);

    return (liTok);
}


/******************************************************************************
 * foiGetGroup8
 *
 * DESCRIPTION:
 * Get Group 8
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * next token
 ******************************************************************************
 */
int foiGetGroup8 (int iToken)
{
    int		liTok;

    if (fofSegError (iToken, PAT_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    *pp_g8 = (struct s_group_8*) timm_malloc (sizeof (struct s_group_8));
    p_g8 = *pp_g8;

    pp_dtm = &(p_g8->dtm);

    p_g8->pat = p_pat;

    liTok = yylex ();			/* Get next segment */

    /*
     * Get none or more DTM segments
     */
    while (liTok == DTM_SEGMENT) {
	*pp_dtm = p_dtm;
	pp_dtm  = &(p_dtm->dtm_next);
	liTok = yylex ();		/* Get next segment */
    }

    pp_g8  = &(p_g8->g_8_next);

    return (liTok);
}


/******************************************************************************
 * foiGetGroup7
 *
 * DESCRIPTION:
 * Get Group 7
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * next token
 ******************************************************************************
 */
int foiGetGroup7 (int iToken)
{
    int		liTok;

    if (fofSegError (iToken, CUX_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    *pp_g7 = (struct s_group_7*) timm_malloc (sizeof (struct s_group_7));
    p_g7 = *pp_g7;

    p_g7->cux = p_cux;
    pp_g7  = &(p_g7->g_7_next);

    liTok = yylex ();			/* Get next segment */

    return (liTok);
}


/******************************************************************************
 * foiGetGroup6
 *
 * DESCRIPTION:
 * Get Group 6
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * next token
 ******************************************************************************
 */
int foiGetGroup6 (int iToken)
{
    int		liTok;

    if (fofSegError (iToken, TAX_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    *pp_g6 = (struct s_group_6*) timm_malloc (sizeof (struct s_group_6));
    p_g6 = *pp_g6;

    p_g6->tax = p_tax;
    pp_g6  = &(p_g6->g_6_next);

    liTok = yylex ();			/* Get next segment */

    return (liTok);
}


/******************************************************************************
 * foiGetGroup5
 *
 * DESCRIPTION:
 * Get Group 5
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * next token
 ******************************************************************************
 */
int foiGetGroup5 (int iToken)
{
    int		liTok;

    if (fofSegError (iToken, CTA_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    *pp_g5 = (struct s_group_5*) timm_malloc (sizeof (struct s_group_5));
    p_g5 = *pp_g5;

    pp_com = &(p_g5->com);

    p_g5->cta = p_cta;

    liTok = yylex ();			/* Get next segment */

    /*
     * Get none or more COM segments
     */
    while (liTok == COM_SEGMENT) {
	*pp_com = p_com;
	pp_com  = &(p_com->com_next);
	liTok = yylex ();		/* Get next segment */
    }

    pp_g5  = &(p_g5->g_5_next);

    return (liTok);
}


/******************************************************************************
 * foiGetGroup4
 *
 * DESCRIPTION:
 * Get Group 4
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * next token
 ******************************************************************************
 */
int foiGetGroup4 (int iToken)
{
    int		liTok;

    if (fofSegError (iToken, DOC_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    *pp_g4 = (struct s_group_4*) timm_malloc (sizeof (struct s_group_4));
    p_g4 = *pp_g4;

    p_g4->doc = p_doc;
    pp_g4  = &(p_g4->g_4_next);

    liTok = yylex ();			/* Get next segment */

    return (liTok);
}


/******************************************************************************
 * foiGetGroup3
 *
 * DESCRIPTION:
 * Get Group 3
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * next token
 ******************************************************************************
 */
int foiGetGroup3 (int iToken)
{
    int		liTok;

    if (fofSegError (iToken, RFF_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    *pp_g3 = (struct s_group_3*) timm_malloc (sizeof (struct s_group_3));
    p_g3 = *pp_g3;

    p_g3->rff = p_rff;
    pp_g3  = &(p_g3->g_3_next);

    liTok = yylex ();			/* Get next segment */

    return (liTok);
}


/******************************************************************************
 * foiGetGroup2
 *
 * DESCRIPTION:
 * Get Group 2
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * next token
 ******************************************************************************
 */
int foiGetGroup2 (int iToken)
{
    int		liTok;

    if (fofSegError (iToken, NAD_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    *pp_g2 = (struct s_group_2*) timm_malloc (sizeof (struct s_group_2));
    p_g2 = *pp_g2;

    p_g2->nad = p_nad;

    pp_fii = &(p_g2->fii);
    pp_g3  = &(p_g2->g_3);
    pp_g4  = &(p_g2->g_4);
    pp_g5  = &(p_g2->g_5);

    liTok = yylex ();			/* Get next segment */

    /*
     * Get none or more FII segments
     */
    while (liTok == FII_SEGMENT) {
	*pp_fii = p_fii;
	pp_fii  = &(p_fii->fii_next);
	liTok = yylex ();		/* Get next segment */
    }

    /* Group 3 now conditionally */
    while (liTok == RFF_SEGMENT) {
	liTok = foiGetGroup3 (liTok);
    }

    /* Group 4 now conditionally */
    while (liTok == DOC_SEGMENT) {
	liTok = foiGetGroup4 (liTok);
    }

    /* Group 5 now conditionally */
    while (liTok == CTA_SEGMENT) {
	liTok = foiGetGroup5 (liTok);
    }

    pp_g2  = &(p_g2->g_2_next);

    return (liTok);
}


/******************************************************************************
 * foiGetGroup1
 *
 * DESCRIPTION:
 * Get Group 1
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * next token
 ******************************************************************************
 */
int foiGetGroup1 (int iToken)
{
    int		liTok;

    if (fofSegError (iToken, RFF_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    *pp_g1 = (struct s_group_1*) timm_malloc (sizeof (struct s_group_1));
    p_g1 = *pp_g1;

    p_g1->rff = p_rff;
    pp_g1  = &(p_g1->g_1_next);

    liTok = yylex ();			/* Get next segment */

    return (liTok);
}


/******************************************************************************
 * foiGetTimm
 *
 * DESCRIPTION:
 * Get TIMM message
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * 0 - no error
 ******************************************************************************
 */
int foiGetTimm (int iToken)
{
    int		iRet;
    int		liTok;

    iRet = 0;

    if (fofSegError (iToken, UNH_SEGMENT)) 
      {
        return (SEGMENT_ERROR);
      }

    /* Prepare for TIMM message */
    *pp_timm = (struct s_timm_message *) timm_malloc (sizeof (struct s_timm_message));
    p_timm = *pp_timm;

    pp_unh = &(p_timm->unh);
    pp_bgm = &(p_timm->bgm);
    pp_dtm = &(p_timm->dtm);
    pp_ftx = &(p_timm->ftx);

    pp_g1  = &(p_timm->g_1);
    pp_g2  = &(p_timm->g_2);
    pp_g6  = &(p_timm->g_6);
    pp_g7  = &(p_timm->g_7);
    pp_g8  = &(p_timm->g_8);
    pp_g22 = &(p_timm->g_22);

    pp_uns = &(p_timm->uns);
    pp_cnt = &(p_timm->cnt);
    pp_g45 = &(p_timm->g_45);
    pp_g47 = &(p_timm->g_47);
    pp_unt = &(p_timm->unt);

    /* Attach the already filled segment */
    p_timm->unh = p_unh;

    liTok = yylex ();			/* Get next segment */

    if (fofSegError (liTok, BGM_SEGMENT)) {
      return (SEGMENT_ERROR);
    }
    *pp_bgm = p_bgm;

    liTok = yylex ();			/* Get next segment */

    /*
     * Check if we have at least one DTM,
     * get the whole bunch of them.
     */
    if (fofSegError (liTok, DTM_SEGMENT)) {
      return (SEGMENT_ERROR);
    }

    while (liTok == DTM_SEGMENT) {
      *pp_dtm = p_dtm;
      pp_dtm  = &(p_dtm->dtm_next);
      liTok = yylex ();		/* Get next segment */
    }

    /*
     * Get none or more FTX segments
     */
    while (liTok == FTX_SEGMENT) {
      *pp_ftx = p_ftx;
      pp_ftx  = &(p_ftx->ftx_next);
      liTok = yylex ();		/* Get next segment */
    }

    /* Group 1 now conditionally */
    while (liTok == RFF_SEGMENT) {
      liTok = foiGetGroup1 (liTok);
    }

    /* Group 2 now conditionally */
    while (liTok == NAD_SEGMENT) {
      liTok = foiGetGroup2 (liTok);
    }

    /* Group 6 now conditionally */
    while (liTok == TAX_SEGMENT) {
      liTok = foiGetGroup6 (liTok);
    }

    /* Group 7 now conditionally */
    while (liTok == CUX_SEGMENT) {
	liTok = foiGetGroup7 (liTok);
    }

    /* Group 8 now conditionally */
    while (liTok == PAT_SEGMENT) {
      liTok = foiGetGroup8 (liTok);
    }

    /* Group 22 now conditionally */
    while (liTok == LIN_SEGMENT) {
      liTok = foiGetGroup22 (liTok);
    }

    /* UNS is mandatory */
    if (fofSegError (liTok, UNS_SEGMENT)) {
      return (SEGMENT_ERROR);
    }
    *pp_uns = p_uns;

    liTok = yylex ();			/* Get next segment */

    /*
     * Check if we have at least one Group45,
     * get the whole bunch of them.
     */
    /*
    if (fofSegError (liTok, MOA_SEGMENT)) {
      return (SEGMENT_ERROR);
    }
    */

    /* this is now conditionally */
    while (liTok == MOA_SEGMENT) {
      liTok = foiGetGroup45 (liTok);
    }

    /* Group 47 now conditionally */
    while (liTok == TAX_SEGMENT) {
      liTok = foiGetGroup47 (liTok);
    }

    if (fofSegError (liTok, UNT_SEGMENT)) {
      return (SEGMENT_ERROR);
    }
    *pp_unt = p_unt;

    liTok = yylex ();			/* Get next segment */

    pp_timm = &(p_timm->timm_next);

    return (liTok);
}


/******************************************************************************
 * foiGetInter
 *
 * DESCRIPTION:
 * Get interchange
 *
 * PARAMETERS:
 * int		iToken		- Token of first segment
 *
 * RETURNS:
 * 0 - no error
 ******************************************************************************
 */
int foiGetInter (int iToken)
{
    int		iRet;

    iRet = 0;

    if (fofSegError (iToken, UNB_SEGMENT)) {
	return (SEGMENT_ERROR);
    }

    /*
     * Allocate and initialize the interchange structure.
     */
    p_inter = (struct s_TimmInter *) timm_malloc (sizeof (struct s_TimmInter));
    pp_unb  = &(p_inter->unb);
    pp_timm = &(p_inter->timm);
    pp_unz  = &(p_inter->unz);

    pp_alc = &(hold.tmp_alc);
    pp_cta = &(hold.tmp_cta);
    pp_nad = &(hold.tmp_nad);
    pp_rff = &(hold.tmp_rff);
    pp_doc = &(hold.tmp_doc);
    pp_pat = &(hold.tmp_pat);
    pp_pri = &(hold.tmp_pri);
    pp_pcd = &(hold.tmp_pcd);
    pp_tax = &(hold.tmp_tax);
    pp_cux = &(hold.tmp_cux);
    pp_lin = &(hold.tmp_lin);
    pp_cnt = &(hold.tmp_cnt);
    pp_moa = &(hold.tmp_moa);
    pp_unh = &(hold.tmp_unh);
    pp_xcd = &(hold.tmp_xcd);
    
    /* Attach the already filled segment */
    *pp_unb = p_unb;

    /* Get TIMM message */
    iRet = foiGetTimm (yylex ());

    if (fofSegError (iRet, UNZ_SEGMENT)) {
      return (SEGMENT_ERROR);
    }
    /* Attach the already filled segment */
    *pp_unz = p_unz;

    return (0);
}


/******************************************************************************
 * yyparse
 *
 * DESCRIPTION:
 * parser
 * The pointer on the input is 'bgh_input_ptr'; the input string is
 * Null-terminated. The global pointer 'bgh_input_ptr' is increased while
 * parsing the input. The generated structure is appended to 'p_inter'.
 *
 * PARAMETERS:
 *  void
 *
 * RETURNS:
 *  - none -
 ******************************************************************************
 */
int yyparse ()
{
    int	iRet;

    iRet = 0;

    /* for error messages */
    SegNr = 0;
    SegName = "-*-";
    pszCustId = "-";

    /*
     * Build the complete interchange.
     */
    iRet = foiGetInter (yylex ());

    return (iRet);
}


/******************************************************************************
 * free_timm
 *
 * DESCRIPTION:
 * free a interchange structure of TIMM
 *
 * PARAMETERS:
 *  struct s_TimmInter *		- pointer to the TIMM c-structure
 *
 * RETURNS:
 * - void -
 ******************************************************************************
 */
void free_timm (struct s_TimmInter *p_inter)
{
  void *p_free;
  
  if (p_inter->unb != NULL) 
    {
      free (p_inter->unb);
    }

  for (p_timm = p_inter->timm; p_timm;) 
    {
      if (p_timm->unh != NULL) 
        {
          free (p_timm->unh);
        }
      
      if (p_timm->unt != NULL) 
        {
          free (p_timm->unt);
        }

      if (p_timm->bgm != NULL) 
        {
          free (p_timm->bgm);
        }

      for (p_dtm = p_timm->dtm; p_dtm;) 
        { 
          p_free = (void *) p_dtm;
          p_dtm = p_dtm->dtm_next;
          free (p_free);
        }

      for (p_ftx = p_timm->ftx; p_ftx;) 
        { 
          p_free = (void *) p_ftx;
          p_ftx=p_ftx->ftx_next;
          free (p_free);
        }

      for (p_g1 = p_timm->g_1; p_g1;) 
        { 
          free (p_g1->rff);
          p_free = (void *) p_g1;
          p_g1 = p_g1->g_1_next;
          free (p_free);
        }

      for (p_g2 = p_timm->g_2; p_g2;) 
        { 
          free (p_g2->nad);
          
          for (p_fii = p_g2->fii; p_fii;) 
            { 
              p_free = (void *) p_fii;
              p_fii = p_fii->fii_next;
              free (p_free);
            }

          for (p_g3 = p_g2->g_3; p_g3;) 
            { 
              free (p_g3->rff);
              p_free = (void *) p_g3;
              p_g3 = p_g3->g_3_next;
              free (p_free);
            }

          for (p_g4 = p_g2->g_4; p_g4;) 
            {
              free (p_g4->doc);
              p_free = (void *) p_g4;
              p_g4 = p_g4->g_4_next;
              free (p_free);
            }

          for (p_g5 = p_g2->g_5; p_g5;) 
            {
              free (p_g5->cta);

              for (p_com = p_g5->com; p_com;) 
                {
                  p_free = (void *) p_com;
                  p_com = p_com->com_next;
                  free (p_free);
                }

              p_free = (void *) p_g5;
              p_g5 = p_g5->g_5_next;
              free (p_free);
            }

          p_free = (void *) p_g2;
          p_g2 = p_g2->g_2_next;
          free (p_free);
        }

      for (p_g6 = p_timm->g_6; p_g6;) 
        {
          free (p_g6->tax);
          p_free = (void *) p_g6;
          p_g6 = p_g6->g_6_next;
          free (p_free);
        }

      for (p_g7 = p_timm->g_7; p_g7;) 
        {
          free (p_g7->cux);
          p_free = (void *) p_g7;
          p_g7 = p_g7->g_7_next;
          free (p_free);
        }

      for (p_g8 = p_timm->g_8; p_g8;) 
        {
          free (p_g8->pat);

          for (p_dtm = p_g8->dtm; p_dtm;) 
            {
              p_free = (void *) p_dtm;
              p_dtm = p_dtm->dtm_next;
              free (p_free);
            }

          p_free = (void *) p_g8;
          p_g8 = p_g8->g_8_next;
          free (p_free);
        }

      for (p_g22 = p_timm->g_22; p_g22;) 
        {
          free (p_g22->lin);

          for (p_pia = p_g22->pia; p_pia;) 
            {
              p_free = (void *) p_pia;
              p_pia = p_pia->pia_next;
              free (p_free);
            }

          for (p_imd = p_g22->imd; p_imd;) 
            {
              p_free = (void *) p_imd;
              p_imd = p_imd->imd_next;
              free (p_free);
            }

          for (p_qty = p_g22->qty; p_qty;) 
            {
              p_free = (void *) p_qty;
              p_qty = p_qty->qty_next;
              free (p_free);
            }

          for (p_dtm = p_g22->dtm; p_dtm;) 
            {
              p_free = (void *) p_dtm;
              p_dtm = p_dtm->dtm_next;
              free (p_free);
            }

          for (p_ftx = p_g22->ftx; p_ftx;) 
            {
              p_free = (void *) p_ftx;
              p_ftx = p_ftx->ftx_next;
              free (p_free);
            }

          for (p_g23 = p_g22->g_23; p_g23;) 
            {
              free (p_g23->moa);
              p_free = (void *) p_g23;
              p_g23 = p_g23->g_23_next;
              free (p_free);
            }

          for (p_g25 = p_g22->g_25; p_g25;) 
            {
              free (p_g25->pri);
              p_free = (void *) p_g25;
              p_g25 = p_g25->g_25_next;
              free (p_free);
            }

          for (p_g26 = p_g22->g_26; p_g26;) 
            {
              free (p_g26->rff);
              p_free = ( void *) p_g26;
              p_g26 = p_g26->g_26_next;
              free (p_free);
            }

          for (p_g30 = p_g22->g_30; p_g30;) 
            {
              free (p_g30->tax);

              for (p_moa = p_g30->moa; p_moa;) 
                {
                  p_free = (void *) p_moa;
                  p_moa = p_moa->moa_next;
                  free (p_free);
                }

              p_free = (void *) p_g30;
              p_g30 = p_g30->g_30_next;
              free (p_free);
            }

          for (p_g31 = p_g22->g_31; p_g31;) 
            {
              free (p_g31->nad);
              for (p_loc = p_g31->loc; p_loc;) 
                {
                  p_free = (void *) p_loc;
                  p_loc = p_loc->loc_next;
                  free (p_free);
                }

              p_free = (void *) p_g31;
              p_g31 = p_g31->g_31_next;
              free (p_free);
            }

          for (p_g35 = p_g22->g_35; p_g35;) 
            {
              free (p_g35->alc);
              if (p_g35->g_37 != NULL) 
                {
                  p_g37=p_g35->g_37;
                  free (p_g37->pcd);
                  free (p_g37);
                }

              for (p_g38 = p_g35->g_38; p_g38;) 
                {
                  free (p_g38->moa);
                  p_free = (void *) p_g38;
                  p_g38 = p_g38->g_38_next;
                  free (p_free);
                }

              for (p_g40 = p_g35->g_40; p_g40;) 
                {
                  free (p_g40->moa);
                  p_free = (void *) p_g40;
                  p_g40 = p_g40->g_40_next;
                  free (p_free);
                }

              p_free = (void *) p_g35;
              p_g35 = p_g35->g_35_next;
              free (p_free);
            }

          for (p_g99 = p_g22->g_99; p_g99;) 
            {
              free (p_g99->xcd); 
              p_free = (void *) p_g99;
              p_g99 = p_g99->g_99_next;
              free (p_free);
            }

          p_free = (void *) p_g22;
          p_g22 = p_g22->g_22_next;
          free (p_free);
        }

      if (p_timm->uns != NULL) 
        {
          free (p_timm->uns);
        }
      
      for (p_cnt = p_timm->cnt; p_cnt;) 
        {
          p_free = (void *) p_cnt;
          p_cnt = p_cnt->cnt_next;
          free (p_free);
        }

      for (p_g45 = p_timm->g_45; p_g45;) 
        {
          free (p_g45->moa);
          p_free = (void *) p_g45;
          p_g45 = p_g45->g_45_next;
          free (p_free);
        }

      for (p_g47 = p_timm->g_47; p_g47;) 
        {
          free (p_g47->tax);

          for (p_moa = p_g47->moa; p_moa;) 
            {
              p_free = (void *) p_moa;
              p_moa = p_moa->moa_next;
              free (p_free);
            }

          p_free = (void *) p_g47;
          p_g47 = p_g47->g_47_next;
          free (p_free);
        }

      p_free = (void *) p_timm;
      p_timm = p_timm->timm_next;
      free (p_free);
    } /* of timm_message */

  if (p_inter->unz != NULL) 
    {
      free (p_inter->unz);
    }
  
  if (p_inter != NULL) 
    {
      free (p_inter);
    }
}

void free_g22(struct s_group_22 *p_g22)
{
  void *p_free;

  for (p_g22 = p_timm->g_22; p_g22;) 
    {
      free (p_g22->lin);
      
      for (p_pia = p_g22->pia; p_pia;) 
        {
          p_free = (void *) p_pia;
          p_pia = p_pia->pia_next;
          free (p_free);
        }
      
      for (p_imd = p_g22->imd; p_imd;) 
        {
          p_free = (void *) p_imd;
          p_imd = p_imd->imd_next;
          free (p_free);
        }
      
      for (p_qty = p_g22->qty; p_qty;) 
        {
          p_free = (void *) p_qty;
          p_qty = p_qty->qty_next;
          free (p_free);
        }
      
      for (p_dtm = p_g22->dtm; p_dtm;) 
        {
          p_free = (void *) p_dtm;
          p_dtm = p_dtm->dtm_next;
          free (p_free);
        }
      
      for (p_ftx = p_g22->ftx; p_ftx;) 
        {
          p_free = (void *) p_ftx;
          p_ftx = p_ftx->ftx_next;
          free (p_free);
        }
      
      for (p_g23 = p_g22->g_23; p_g23;) 
        {
          free (p_g23->moa);
          p_free = (void *) p_g23;
          p_g23 = p_g23->g_23_next;
          free (p_free);
        }
      
      for (p_g25 = p_g22->g_25; p_g25;) 
        {
          free (p_g25->pri);
          p_free = (void *) p_g25;
          p_g25 = p_g25->g_25_next;
          free (p_free);
        }

      for (p_g26 = p_g22->g_26; p_g26;) 
        {
          free (p_g26->rff);
          p_free = ( void *) p_g26;
          p_g26 = p_g26->g_26_next;
          free (p_free);
        }

      for (p_g30 = p_g22->g_30; p_g30;) 
        {
          free (p_g30->tax);
          
          for (p_moa = p_g30->moa; p_moa;) 
            {
              p_free = (void *) p_moa;
              p_moa = p_moa->moa_next;
              free (p_free);
            }
          
          p_free = (void *) p_g30;
          p_g30 = p_g30->g_30_next;
          free (p_free);
        }

      for (p_g31 = p_g22->g_31; p_g31;) 
        {
          free (p_g31->nad);
          for (p_loc = p_g31->loc; p_loc;) 
            {
              p_free = (void *) p_loc;
              p_loc = p_loc->loc_next;
              free (p_free);
            }
          
          p_free = (void *) p_g31;
          p_g31 = p_g31->g_31_next;
          free (p_free);
        }
      
      for (p_g35 = p_g22->g_35; p_g35;) 
        {
          free (p_g35->alc);
          if (p_g35->g_37 != NULL) 
            {
              p_g37=p_g35->g_37;
              free (p_g37->pcd);
              free (p_g37);
            }

          for (p_g38 = p_g35->g_38; p_g38;) 
            {
              free (p_g38->moa);
              p_free = (void *) p_g38;
              p_g38 = p_g38->g_38_next;
              free (p_free);
            }
          
          for (p_g40 = p_g35->g_40; p_g40;) 
            {
              free (p_g40->moa);
              p_free = (void *) p_g40;
              p_g40 = p_g40->g_40_next;
              free (p_free);
            }
          
          p_free = (void *) p_g35;
          p_g35 = p_g35->g_35_next;
          free (p_free);
        }
      
      for (p_g99 = p_g22->g_99; p_g99;) 
        {
          free (p_g99->xcd); 
          p_free = (void *) p_g99;
          p_g99 = p_g99->g_99_next;
          free (p_free);
        }
      
      p_free = (void *) p_g22;
      p_g22 = p_g22->g_22_next;
      free (p_free);
    }
}

extern long lNrTIMM, lLenTIMM;


/******************************************************************************
 * PrintVersInfoBghPYacc
 *
 * DESCRIPTION:
 * print the version info
 *
 * PARAMETERS:
 *  void
 *
 * RETURNS:
 *  - none -
 ******************************************************************************
 */
void PrintVerInfoBghPYacc (void)
{
  char *SCCS_VERSION = "1.1";

  printf ("%s\t\t\t%s\n", __FILE__, SCCS_VERSION);
}

/******************************************************************************
 * PrintVersInfoBghPLex
 *
 * DESCRIPTION:
 * empty dummy function
 *
 * PARAMETERS:
 *  void
 *
 * RETURNS:
 *  - none -
 ******************************************************************************
 */
void PrintVerInfoBghPLex (void)
{
}


/******************************************************************************
 * parse_timm
 *
 * DESCRIPTION:
 * parse a timm message and return a pointer to an interchange
 * structure
 *
 * PARAMETERS:
 *  char 	*input_string		- pointer to the TIMM string
 *
 * RETURNS:
 *  struct s_TimmInter *		- pointer to the TIMM c-structure
 ******************************************************************************
 */

long lNrTIMM;
long lLenTIMM;

struct s_TimmInter *parse_timm (char *input_string)
{
  lNrTIMM++;
  
  bgh_input     = input_string;
  bgh_input_ptr = bgh_input;
  
  yyparse ();
  
  lLenTIMM += (bgh_input_ptr - bgh_input);

  if (goenVerbose == TRUE)
    {
      fprintf(stderr, "Parsed\n");
    }
  
  return (p_inter);
}

struct s_TimmInter *fpstParser_Parse(char *ppchzInput)
{
  if (ppchzInput == NULL)
    {
      return NULL;
    }

  if (goenVerbose == TRUE)
    {
      /*
      fprintf(stderr, "Parsing string:\n>>>>\n%s\n<<<<\n", ppchzInput);
      */
    }

  return parse_timm (ppchzInput);
}
  





